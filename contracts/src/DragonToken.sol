// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.21;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title DragonToken
 * @notice ERC20 token "Dragon Essence" (DGNE) - Generated by staking dragons.
 * @dev Minting is restricted to authorized contracts (staking).
 *      Burning is public (for battle entry, healing, minting creatures).
 */
contract DragonToken is ERC20, ERC20Burnable, Ownable, Pausable {
    
    // Contracts authorized to mint tokens
    mapping(address => bool) public minters;
    
    // Events
    event MinterSet(address indexed account, bool authorized);
    
    constructor() ERC20("Dragon Essence", "DGNE") Ownable(msg.sender) {
        // Owner can mint initially for testing
        minters[msg.sender] = true;
    }
    
    // ============ Modifiers ============
    
    modifier onlyMinter() {
        require(minters[msg.sender], "DragonToken: not a minter");
        _;
    }
    
    // ============ Mint (Restricted) ============
    
    /**
     * @notice Mint tokens to an address (only authorized minters)
     * @param to Recipient address
     * @param amount Amount to mint in wei
     */
    function mint(address to, uint256 amount) external onlyMinter whenNotPaused {
        _mint(to, amount);
    }
    
    // ============ Admin Functions ============
    
    /**
     * @notice Set minter authorization
     * @param account Address to authorize/deauthorize
     * @param authorized Whether address can mint
     */
    function setMinter(address account, bool authorized) external onlyOwner {
        minters[account] = authorized;
        emit MinterSet(account, authorized);
    }
    
    /**
     * @notice Pause all token transfers
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    /**
     * @notice Unpause token transfers
     */
    function unpause() external onlyOwner {
        _unpause();
    }
    
    // ============ Overrides ============
    
    /**
     * @dev Prevent transfers when paused
     */
    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {
        super._update(from, to, value);
    }
}
